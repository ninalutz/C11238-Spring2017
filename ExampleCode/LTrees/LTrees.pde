/*
Script that draws a variety of L-System trees 

Can be stagnant, random L-Systems or dynamic ones generated by moving your mouse

Easily customizable 
*/

boolean loop, multiple;
boolean center = true;
int amount = 10;
int [] max_level, size, angle, fan, shift;
boolean directions = true;

void setup() {
  size(1200, 700);
  //generate random arrays for all tree properties
  max_level = Generated_Array(amount, 5, 10);
  size = Generated_Array(amount, 300, 500);
  angle = Generated_Array(amount, 50, 100);
  fan = Generated_Array(amount, -40, 40);
  shift = Generated_Array(amount, width/3, width);
  
    if(!loop){
  noLoop();
  }
  
  else{
    loop();
  }
}

void draw() {

  background(255);
  fill(0);
  
  //translate(width/2, height/2 + 100);
  strokeWeight(10);

  //draws stagnant L-Systems 
  if(!loop){
   pushMatrix();
          for(int i = 0; i<amount; i++){
            float a = width/2;
            float b = height/2+100;
            translate(-a, b);
            stroke(0);
            tree(level, max_level[i], size[i], ratio, angle[i], fan[i]);
            a = shift[i];
            translate(a, -b);
          }
    popMatrix();
  }
 
  else{
    pushMatrix();
    stroke(0);
    translate(width/2, height/2+100);
    
    //draws the singular l system tree
    if(!multiple){
    tree(1, 10, 200, ratio, map(mouseY, 0, height, 0, 90), map(mouseX, 0, width, 45, -45));
    }
    
    //these are just some I did by hand, but you can easily experiment or generate them randomly
    if(multiple){
    tree(1, 10, 200, ratio, map(mouseY , 0, height, 0, 90), map(mouseX, 0, width, 45, -45));
    rotate(180);
    tree(1, 10, 300, ratio, map(mouseY, 0, height, 0, 90), map(mouseX, 0, width, 45, -45));
    rotate(60);
    tree(1, 10, 400, ratio, map(mouseY , 0, height, 20, 100), map(mouseX , 0, width, 100, -45));
    rotate(50);
    tree(1, 10, 400, ratio, map(mouseY , 0, height, 20, 100), map(mouseX , 0, width, 100, -45));
    tree(1, 10, 300, ratio, map(mouseY, 0, height, 0, 90), map(100, 400, width, 45, -45));
    translate(200, -500);
    rotate(-45);
    tree(1, 6, 300, ratio, map(mouseY, 50, height, 0, 90), map(mouseX, 0, width, 45, -20));
    rotate(-90);
    tree(1, 10, 500, ratio, map(mouseY + 50, 0, height, 0, 90), map(mouseX + 50, 0, width, 45, -45));
    translate(width/2, 0);
    tree(1, 10, 500, ratio, map(mouseY + 500, 0, height, 0, 90), map(mouseX + 50, 0, width, 45, -45));
    translate(0, -width);
    tree(1, 10, 500, ratio, map(mouseY + 500, 0, height, 0, 90), map(mouseX + 50, 0, width, 45, -45));
    tree(1, 10, 300, ratio, map(mouseY, 0, height, 0, 90), map(mouseX, 0, width, 45, -45)); 
    }
    popMatrix();
  }
  
  //toggles display of instructions
  if(directions){
    fill(255);
    noStroke();
    rect(0, 0, 700, 30);
    fill(0);
    text("Press 'm' to get many dynamic trees, 'a' for a single tree, and space to get a random, stagnant pattern", 20, 20);
  }

 
}

void mouseDragged(){
    ratio += float(mouseY - pmouseY)*0.1;
}

void keyPressed(){
  switch(key){
  case ' ': 
    loop = false;
    setup();
    redraw();
    break;
  case 'a': 
    loop = true;
    multiple = false;
    setup();
    redraw();
    break;  
   case 'm': 
    loop = true;
    center = false;
    multiple = !multiple;
    setup();
    redraw();
    break;  
  case 'c': 
    loop = true;
    center = true;
    multiple = false;
    setup();
    redraw();
    break; 
  }
}
